# Spring + WebFlux + R2dbc + Postgres

Точкой входа в миграцию является endpoint **POST '/startExecutor'**. Единственным параметром на вход в миграцию является 
Составной параметр **MigrationConfig**. Где в первую очередь определяется оттуда и куда делается миграция.

При старте миграции в базу добавляется root object с полями из конфига.
Далее Executor занимается тем что **сканирует** базу на предмет индексов со статусом NEW (при первом скане это будет только root object).
Как только он их находит то, ставит им статус CAPTURED и передается в **MigrationWorker** которые submit(execute) в executor
Статус **CAPTURED** нужен для того чтобы при следующем **скане** этот объект не попал в обработку и не был передан в другой worker
Иначе он будет обрабатываться более чем один worker одновременно
В самом workers происходит работа с Source object и Target object (read/write).
основная операция это **getChildren** которая получает child objects и записывает их в базу со статусом NEW
Но это происходит только в том случае если target object был создан (операция **create**), потому что иначе нам некуда будет создавать child объекты
в target системе.

Если **MigrationWorker** упал, то объект записывается в базу как **FAILED**
**MigrationWorker** требует доработки, надо выносить функционал в отдельный Service, может быть много операций с объектом,
для каждой операции надо сделать колонку в базе чтобы туда записывать результат операции - OK, или текст ошибки, для того чтобы можно было после
окончания миграции запустить migrate failed items. Сейчас в **MigrationWorker** только операции create/getChildren.

Demo сценарий выглядит так:
1. Запускается миграция из **FakeContext** в **FakeContext** с таким набором параметром чтобы миграция шла долго. К примеру:

   `{
      "sourceContext": {
         "type": "com.migration.context.FakeContext",
         "levelsCount": 10,
         "containersCount": 10,
         "contentCount": 10
      },
         "targetContext": {
         "type": "com.migration.context.FakeContext"
      }
   }`

2. Берется id миграции (configId) и передается на фронт, фронт постоянно вызывает reactive endpoint **GET '/monitor'** получая список всех объектов для данной миграции
   (это для потенциального progress bar на фронте)
3. Фронт получая данные в реактивном потоке отображает их в компоненте.


Приложение постоянно дорабатывается.